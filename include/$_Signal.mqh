void Signal (int SigMode, int SigType, int K, int bar){  // Сигналы и направления тренда  SigMode=1-расчет тренда, 
   double x0,x1,x2,x3,x4,C1,C2,H1,H2,L1,L2; //                              SigMode=2-расчет сигнала
   Up=0; Dn=0;            
   bool TREND=0, SIGNAL=0; int k, indper;
   if (SigMode==1) TREND=1; else  SIGNAL=1;
   switch (SigType){ 
      case 1:// сигналы по 0Layers, тут H1,L1 обозначают экстремумы разных уровней ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         switch(K){
            case 1:  // возьмем нулевой уровень для индюка 0Layers (N=2), при этом значении он строит 5 уровней
               H1=iCustom(SYMBOL,0,"0Layers",2,0,bar); // при N=2 в индюке 0Layers H1=L1,  H4=H3; L4=L3
               L1=H1;
            break;
            case 2:  // теперь начальные уровни для индюка 0Layers (N=1), при этом значении он строит 8 уровней = 4Hi и 4Lo
               H1=iCustom(SYMBOL,0,"0Layers",1,0,bar); // H1
               L1=iCustom(SYMBOL,0,"0Layers",1,4,bar); // L1
            break;
            case 3: //  0Layers(N=2) , тока с более дальними уровнями 1 и 5
               H1=iCustom(SYMBOL,0,"0Layers",2,1,bar); // H2
               L1=iCustom(SYMBOL,0,"0Layers",2,5,bar); // L2
            break;
            case 4: // опять 0Layers(N=1) с теми же уровнями 1 и 5
               H1=iCustom(SYMBOL,0,"0Layers",1,1,bar); // H2
               L1=iCustom(SYMBOL,0,"0Layers",1,5,bar); // L2
            break;
            case 5:  // а теперь еще уровни 1 и 5 для индюка 0Layers (N=Tin+3), при этом значении он строит 5 уровней
               H1=iCustom(SYMBOL,0,"0Layers",Tin,1,bar); // H2
               L1=iCustom(SYMBOL,0,"0Layers",Tin,5,bar); // L2
            break;
            case 6: // перебор уровней 2-6 для индюка 0Layers (N=1)
               H1=iCustom(SYMBOL,0,"0Layers",1,2,bar); // H3
               L1=iCustom(SYMBOL,0,"0Layers",1,6,bar); // L3
            break;
            case 7: // перебор уровней 2-6 для индюка 0Layers (N=2)
               H1=iCustom(SYMBOL,0,"0Layers",2,2,bar); // H3
               L1=iCustom(SYMBOL,0,"0Layers",2,6,bar); // L3
            break;
            case 8: // перебор уровней 2-6 для индюка 0Layers (N=Tin+3)
               H1=iCustom(SYMBOL,0,"0Layers",Tin,2,bar); // H3
               L1=iCustom(SYMBOL,0,"0Layers",Tin,6,bar); // L3
            break;
            case 9: // самые дальние уровни 3-7, они есть тока у 0Layers при (N=1)
               H1=iCustom(SYMBOL,0,"0Layers",1,3,bar); // H4
               L1=iCustom(SYMBOL,0,"0Layers",1,7,bar); // L4 
            break;
            }
         C1=iClose(SYMBOL,0,bar);
         C2=iClose(SYMBOL,0,bar+1);   
         if (C1>H1)  {if (TREND) Up=1; if (SIGNAL && C2<H1) Up=1;}
         if (C2<L1)  {if (TREND) Dn=1; if (SIGNAL && C2>L1) Dn=1;}   
         x0=C1; x1=H1; x2=L1; // эт для файла печати в файл отчета            
      break; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      case 2: // отскоки/приближения к экстремумам HiLo //////////////////////////////////////////////////////////////////////////////////////////////////////
         if (K==5){ // крайний случай - формирование нового экстремума 
            if (TREND){ // Цена HLC/3 в канале
               x0=iCustom(SYMBOL,0,"0OSC",2,HL,iHL,PerCnt,1,bar);   // Индюк рисует "0.5" при появлении нового максимума, и "-0.5" при появлении нового минимума
               if (x0>0) Up=1;                                 // "+" удерживается пока не появится "-" и наоборот, т.е. на один + может сформироваться несколько максимумов     
               if (x0<0) Dn=1; 
               }
            if (SIGNAL){//
               if (HL==8) k=5; else k=PerCnt; // Требуется только при HL=8, если его менять, то надо еще и в Count глянуть
               H1=iCustom(SYMBOL,0,"0HL",HL,iHL,k,0,bar);   
               L1=iCustom(SYMBOL,0,"0HL",HL,iHL,k,1,bar);
               H2=iCustom(SYMBOL,0,"0HL",HL,iHL,k,0,bar+1);   // щитаем прошлые hi / lo
               L2=iCustom(SYMBOL,0,"0HL",HL,iHL,k,1,bar+1);
               if (H1>H2) Up=1;  // объявился новый Hi (в отличии от TREND может последовательно пройти несколько сигналов
               if (L1<L2) Dn=1;  // объявился новый Lo  до появления противоположного)
               x1=H1; x2=L1; x3=H2; x4=L2;
            }  }    
         else{  // при K>1 (цена мечется в канале)
            x0=(5-K)*0.1;   // 0.4  0.3  0.2  0.1  X  -0.1  -0.2  -0.3  0.4      новый экстремум
            x1=iCustom(SYMBOL,0,"0OSC",2,HL,iHL,PerCnt,0,bar);  // Теперь он рисует положение HLC/3 в канале HL, в
            x2=iCustom(SYMBOL,0,"0OSC",2,HL,iHL,PerCnt,0,bar+1);// диапазоне от -0.5 до 0.5
            if (x1> x0) {if (TREND) Up=1; if (SIGNAL && x2<=x0) Up=1;}
            if (x1<-x0) {if (TREND) Dn=1; if (SIGNAL && x2>=-x0) Dn=1;}
            }
      break; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      case 3:// DM приоритетное направление движения цены/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         if (TREND)  indper=NormalizeDouble(MathPow(1.5,K+6),0); // 17  26  38  58  86  130  195  291  438  
         if (SIGNAL) indper=(K+1)*(K+1); 
         x1=iCustom(SYMBOL,0,"0DM",0,indper,PerCnt,0,bar);
         x2=iCustom(SYMBOL,0,"0DM",0,indper,PerCnt,0,bar+1);
         if (x1> 0) {if (TREND) Up=1; if (SIGNAL && x2<=0) Up=1;} 
         if (x1<-0) {if (TREND) Dn=1; if (SIGNAL && x2>=0) Dn=1;}
      break; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      case 4:// Фрактал в ОБЪЕМЕ (площадь над прямой моментума - площадь под прямой моментума)///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         if (TREND)  indper=NormalizeDouble(MathPow(1.5,K+6),0); // 17  26  38  58  86  130  195  291  438  
         if (SIGNAL) indper=(K+2)*(K+2); 
         x1=iCustom(SYMBOL,0,"0DM",2,indper,PerCnt,0,bar);
         x2=iCustom(SYMBOL,0,"0DM",2,indper,PerCnt,0,bar+1);
         if (x1> 1*Point) {if (TREND) Up=1; if (SIGNAL && x2<=0) Up=1;} 
         if (x1<-1*Point) {if (TREND) Dn=1; if (SIGNAL && x2>=0) Dn=1;}
      break; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      case 5: // Фракталы ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////   
         if (TREND){// Тренд фракталу на базе HL
            indper=K*K; // период для HL
            x0=iCustom(SYMBOL,0,"0OSC",5,HL,indper,PerCnt,0,bar);    // если последняя сформированная вершина Lo, то тренд ВВЕРХ...
            if (x0>0) Up=1; else Dn=1;           
            }    
         if (SIGNAL){// сигнал = фрактал
            x3=ATR*K*0.5; // постоянная удаления вершины от краев (отсеиваем плоские фракталы)
            x0=iHigh(SYMBOL,0,K+1); // вершина
            x1=iHigh(SYMBOL,0,iHighest(SYMBOL,0,MODE_HIGH,K,1));  // правая половина фрактала
            x2=iHigh(SYMBOL,0,iHighest(SYMBOL,0,MODE_HIGH,K,K+2));// левая половина
            if (x0>x1  && x0>x2 && Close[1]<x0-x3 && Open[K*2+1]<x0-x3) Dn=1; // "чистый фрактал" (одна вершина, достаточно удаленная от краев)
            x0=iLow (SYMBOL,0,K+1);
            x1=iLow (SYMBOL,0,iLowest (SYMBOL,0,MODE_LOW, K,1));
            x2=iLow (SYMBOL,0,iLowest (SYMBOL,0,MODE_LOW, K,K+2));
            if (x0<x1 && x0<x2 && Close[1]>x0+x3 && Open[K*2+1]>x0+x3) Up=1;
            }     
      break; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

      case 6:// Тренд на сужении/расширении HL, измеренном в ATR, сигнал по VolumeCluster       
         if (TREND){ 
            H1 =iCustom(SYMBOL,0,"0HL",HL,iHL,PerCnt,0,bar);   
            L1 =iCustom(SYMBOL,0,"0HL",HL,iHL,PerCnt,1,bar);
            if (K<6) {x0=ATR*(K+2)*0.5; if ((H1-L1)<x0) {Up=1; Dn=1;}} // при сужении  диапазона HL до значения=ATR*  1.5  2  2.5  3  3.5
            else     {x0=ATR*(K-3)*1.5; if ((H1-L1)>x0) {Up=1; Dn=1;}} // при расширении диапазона HL до значения=ATR* 6  7,5  9  10.5
            x1=H1; x2=L1;
            }  
         if (SIGNAL){  // Свечные фигуры "Повешаннй" и "Надгробие". Тактика определения - VolumeCluster http://gproxyru.appspot.com/http/forex-vc.ru/index.html
            indper=X; // X=
            H1 =iCustom(SYMBOL,0,"0HL",8,K,indper,0,bar-1); // берем нулевой бар, тк индюк считается по прошлым барам  
            L1 =iCustom(SYMBOL,0,"0HL",8,K,indper,1,bar-1);
            x0 =iCustom(SYMBOL,0,"0HL",8,K,indper,2,bar-1); // Сигнал (точка на графике)
            if (x0==L1) Up=1;
            if (x0==H1) Dn=1; 
            x1=H1; x2=L1; 
            }    
      break;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      
      case 7:// Тренд Momentum. Сигнал на разрыве, или оч длинном баре /// 17  26  38  58  86  130  195  291  438//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////     
         if (TREND){ // Классический моментум
            indper=NormalizeDouble(MathPow(1.5,K+6),0); // 17  26  38  58  86  130  195  291  438
            x0=iCustom(SYMBOL,0,"0DM",3,indper,PerCnt,0,bar-1); // считается по открытию, поэтому берем нулевой бар
            if (x0>0) Up=1; else Dn=1;
            }
         if (SIGNAL){//сигнал на разрыве, или оч длинном баре 
            x0=ATR*(2+K*0.4); // 2.4  2.8  3.2  3.6  4  4.4  4.8  5.2  5.6 
            x1=iOpen(SYMBOL,0,bar-1); // открытие нулевого бара
            x2=iOpen(SYMBOL,0,bar); 
            if (x1-x2>x0) Up=1; // наличие разрыва, или оч длинного бара
            if (x2-x1>x0) Dn=1;
            } 
       break; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////       

      case 8: // тренд при сужении/расширенни зафиксированного диапазона HL относительно ATR, Сигналы при образовании новых экстремумов,        
         if (TREND){ // в отличии от п.5 HL считается по другой формуле
            H1=iCustom(SYMBOL,0,"0OSC",3,HL,iHL,PerCnt,1,bar); // Значение последнего максимума (можно использовать нулевой бар, т.к. индюк выдает значения прошлого бара)
            L1=iCustom(SYMBOL,0,"0OSC",3,HL,iHL,PerCnt,0,bar); // Значение последнего минимума
            if (K<6) {x0=ATR*(K+2)*0.5; if ((H1-L1)<x0) {Up=1; Dn=1;}} // при сужении  диапазона HL до значения=ATR*  1.5  2  2.5  3  3.5
            else     {x0=ATR*(K-2)*2;   if ((H1-L1)>x0) {Up=1; Dn=1;}} // при расширении диапазона HL до значения=ATR* 8  10  12  14    
            }
         if (SIGNAL){
            H1=iCustom(SYMBOL,0,"0OSC",4,HL,iHL,PerCnt,1,bar-1); // Значение последнего максимума (можно использовать нулевой бар, т.к. индюк выдает значения прошлого бара)
            L1=iCustom(SYMBOL,0,"0OSC",4,HL,iHL,PerCnt,0,bar-1); // Значение последнего минимума
            H2=iCustom(SYMBOL,0,"0OSC",4,HL,iHL,PerCnt,1,bar);
            L2=iCustom(SYMBOL,0,"0OSC",4,HL,iHL,PerCnt,0,bar);
            if (K<6){ // x0= 0.75  0.6  0.45  0.3  0.15 
               x0=(H2-L2)*(6-K)*0.15;
               if (L1>L2+x0) Up=1; // сформировался очередной минимум выше предыдущего 
               if (H1<H2-x0) Dn=1; // сформировался очередной максимум ниже предыдущего 
               }
            else{ // x0= 0.15  0.3  0.45  0.6 
               x0=(H2-L2)*(K-5)*0.15;
               if (L1<L2-x0) Up=1; // сформировался очередной минимум ниже предыдущего  
               if (H1>H2+x0) Dn=1; // сформировался очередной максимум выше предыдущего
               }
            x1=H1; x2=L1;   
            }   
       break;/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

      case 9: // сужение/расширение канала HL относительно предыдущих значений ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         if (TREND){ 
            if (K<6) x0=(K+1)*0.15; else x0=(K+2)*0.2;          
            x1=iCustom(SYMBOL,0,"0OSC",1,HL,iHL,PerCnt,1,bar);    // Последний диапазон HL
            x2=iCustom(SYMBOL,0,"0OSC",1,HL,iHL,PerCnt,0,bar);    // тренд при сужении/расширении канала HL относительно среднестатистического значения, щитаем среднее значение N диапазонов HL (N=30 - задается внутри индюка от балды)// 
            }
         if (SIGNAL){ 
            if (K<6) x0=(K+2)*0.15; else x0=K*0.2;
            x1=iCustom(SYMBOL,0,"0OSC",1,HL,iHL,PerCnt,1,bar);    // Последний диапазон HL
            x2=iCustom(SYMBOL,0,"0OSC",1,HL,iHL,PerCnt,1,bar+1);  // сигнал при сужении/расширении канала HL относительно предыдущего значения, щитаем ПредПоследний диапазон HL
            }
         if (K<6) {if (x1<x2*x0)  {Up=1; Dn=1;}} // при сужении  диапазона   HL в  0.3  0.45  0.6  0.75  0.9  раз    
         else     {if (x1>x2*x0)  {Up=1; Dn=1;}} // при расширении диапазона HL в  1.2  1.35  1.5  1.65       раз
      break; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

      case 10: // сигнал, тренд по сужению/расширению ATR /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
         x1=atr;  x2=ATR;
         if (x1<=0 || x2<=0) break;
         if (K<6) {x0=(K+4)*0.1;  if (x1/x2<x0) {Up=1; Dn=1;}}  // при уменьшении atr в   0.5  0.6  0.7  0.8  0.9
         else     {x0=(15-K)*0.1; if (x2/x1<x0) {Up=1; Dn=1;}}  // при увеличении atr в   0.9  0.8  0.7  0.6      
      break; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
      default: //  без всяких фильтров  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
         Up=1; Dn=1; 
      break; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      }
   if (Check){  // сохраним значения индюков для сравнения Real / Test 
      switch(SigMode){
         case 1:
            PS[0]=x0; // Tr0 
            PS[1]=x1; // Tr1
            PS[2]=x2; // Tr2
            PS[3]=x3; // Tr3
         break;   
         case 2:
            PS[4]=x0; // In0
            PS[5]=x1; // In1
            PS[6]=x2; // In2
            PS[7]=x3; // In3
         break;   
         case 3:
            PS[8] =x0; // Out0
            PS[9] =x1; // Out1
            PS[10]=x2; // Out2
            PS[11]=x3; // Out3
         break;     
   }  }  }


