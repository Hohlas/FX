double   NewHi, NewLo, LastHi, LastLo, HH, LL, HHH, LLL,
         FirstUp, FirstDn, // Первый уровень на продажу/покупку
         FirstUpCenter, FirstDnCenter, // серединки первых уровней на продажу/покупку
         FirstUpPic, FirstDnPic, // трендовые уровни первых уровней
         FlatHi, FlatLo, // флэтовые уровни (при двойном касании)
         MostVisited, // наиболее посещаемый уровень между первыми уровнями
         MovUp[5], MovDn[5], // массивы движений, инициализируюстя в init() на Movements членов
         TargetUp, TargetDn, // цели движения
         MidMovUp, MidMovDn, // среднее значение нескольких пследних подобных движений
         HighestLo, // самая высокая впадина на пробой
         LowestHi,  // самая низкая вершина на пробой
         UP1, DN1, // ближайшие уровни
         UP2, DN2, // флэтовые уровни с PowerCheck отскоками
         UP3, DN3, DN3Pic, UP3Pic, UpCenter, DnCenter; // трендовые уровни, их пики и серединки
int   LevelsAmount=50, Trend=0, HiTime, LoTime;
int   Tup1,Tdn1,Tup2,Tdn2; // время формирования уровней UP1,...DN2  
int   TrendLevels[5], TrLevCnt; // массив с последними пятью трендовыми уровнями для вычисления стопа       
int   LEV[1][10], Impulse, 
      u1, u2, u3, d1, d2, d3, um, dm, // индексы массива уровней UP1..DN3
      intH, intL,  // HH и LL текущего бара для сравнения
      Movements=3,  // кол-во последних движений для определения измеренного движения
      LastDir, FrDir, // направление пика для крупных фракталов с периодом LevPer
      LastUp=0, LastDn=0, // номера уровней в массиве, близкий к HH(LL) при прошлом подсчете. Чтобы не перебирать весь массив с одного до другого края, а начинать с этой ячейки. 
      TrendLevBreakUp=0, TrendLevBreakDn=0, // факт пробоя трендового уровня на продажу/покупку для смены тренда. При пробое уровня на продажу TrendLevBreakUp увеличивается на 1, а TrendLevBreakDn обнуляется. И наоборот
      GlobalTrend, // тренд определяемый пробоем первых (сильных) уровней на покупку/продажу 
      FirstUpTime, FirstDnTime, // время образования первых уровней
      FlatHiTime,  FlatLoTime,   // время формирования последнего пика флэта
      FlatTime;
struct PicLevels{  //  C Т Р У К Т У Р А   P I C
   int   Dir;  // направление пика для мелких фракталов с периодом PicPer: 1-вершина, -1-впадина
   int   Free; // освободившийся член 
   double New; // последний из сформировавшихся
   double Atr; // используемый при расчетах 
   int    intAtr; // целый АТР
   double Avg; // средняя толщина последних пяти трендовых для расстановки стопов
   double MirUp;  // зеркальный уровень сверху
   double MirDn;  // зеркальный уровень снизу
   int MirUpTime; // время возникновения зеркального уровня сверху
   int MirDnTime; // время возникновения зеркального уровня снизу
   double Lim;    // точность совпадения уровней
   } Pic;    

            
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
void LEVELS_MAIN(){// ОСНОВНОЙ ЦИКЛ ПОИСКА УРОВНЕЙ
   Pic.New=0;
   HH =High[iHighest(NULL,0,MODE_HIGH,PicPer*2+1,bar)];   // Короткие фракталы для 
   LL =Low [iLowest (NULL,0,MODE_LOW ,PicPer*2+1,bar)];   // формирования уровней в NEW_LEVEL().
   HHH=High[iHighest(NULL,0,MODE_HIGH,LevPer*2+1,bar)];   // Полноценные фракталы для
   LLL=Low [iLowest (NULL,0,MODE_LOW ,LevPer*2+1,bar)];   // определения ложняков, тренда, ближайших и целевых уровней...
   intH  =int(High[bar]/Point);
   intL  =int(Low [bar]/Point);
   Pic.Atr=iATR(NULL,0,SlowAtrPer,bar); if (Pic.Atr==0) return;
   Pic.intAtr=int(Pic.Atr/Point);
   if (High[bar+PicPer]==HH){ // Новый мелкий фрактал  ///////////////////////////////////////////////////////
      Pic.New=HH; Pic.Dir=1;
      Impulse=int(((HH-Low[bar+PicPer-1])+(HH-Low[bar+PicPer+1]))*0.5*PowerPlus/Pic.Atr); // сила импульса, с которой цена отскакивает от уровня, будет добавляться в живучесть
      NEW_LEVEL();
      }
   if (Low[bar+PicPer]==LL){ // Новый мелкий фрактал  /////////////////////////////////////////////////////////
      Pic.New=LL; Pic.Dir=-1;  
      Impulse=int(((High[bar+PicPer-1]-LL)+(High[bar+PicPer+1]-LL))*0.5*PowerPlus/Pic.Atr); // сила импульса, с которой цена отскакивает от уровня, будет добавляться в живучесть
      NEW_LEVEL();
      }
   if (High[bar+LevPer]==HHH){// // Новый крупный фрактал
      LastHi=NewHi;  NewHi=HHH; LastDir=FrDir; FrDir=1; HiTime=int(Time[bar+PicPer]); // 
      TARGET_COUNT();// расчет целевых уровней окончания движения на основании измерения предыдущих безоткатных движений 
      LIM_DETECT(); // определение Pic.Lim допуск совпадения уровней
      }  
  if (Low[bar+LevPer]==LLL){// Новый крупный фрактал
      LastLo=NewLo; NewLo=LLL;  LastDir=FrDir; FrDir=-1; LoTime=int(Time[bar+PicPer]);//
      TARGET_COUNT();// расчет целевых уровней окончания движения на основании измерения предыдущих безоткатных движений
      LIM_DETECT(); // определение Pic.Lim допуск совпадения уровней
      }  
   if (TimeHour(Time[bar])<TimeHour(Time[bar+1])){ // Н О В Ы Й   Д Е Н Ь       
      // if (Prn) Print(ttt,"NewDay ","  ",TimeToString(Time[bar],TIME_DATE | TIME_MINUTES)," LastHi=",LastHi);
      }  
   LEVELS_FIND_AROUND(); // П О И С К   Б Л И З Л Е Ж А Щ И Х   У Р О В Н Е Й      
   TREND_DETECT();   // О П Р Е Д Е Л Е Н И Е   Т Р Е Н Д А 
   switch (FlsLev){// Р А С Ч Е Т   Л О Ж Н Я К О В , т.е. ложняк формируется при пробитии:    
      case 1: FALSE_LEVELS (NewHi,HiTime,NewLo,LoTime); break;  // последнего пика
      case 2: FALSE_LEVELS (UP1,Tup1,DN1,Tdn1); break;  // ближайшего уровня c одним и более отскоком
      case 3: FALSE_LEVELS (UP2,Tup2,DN2,Tdn2); break;  // сильного флэтового уровня с двумя и более отскоками
      case 4: if (Trend==0) FALSE_LEVELS (FlatHi,FlatHiTime,FlatLo,FlatLoTime); break;  // флэтового уровня образовавшегося канала
   }  }
   
     
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ      
void NEW_LEVEL(){
   int NEW =int(Pic.New/Point);   // целочисленное Pic.New
   int LIM=int(Pic.Lim/Point);  // Допуск совпадения уровней
   int f,j=0, Shift, center=0, pwr, From=bar, FrPeriod=2, BreakBars; 
   int ExPicTime=0; // время ближайшшего превосходящего пика перед новым (для вершины - предыдущей вершины, для впадины - предыдущей впадины)
   int OppositeTop; // номер бара противоположная вершина, лежащая между новым и превосходящим его пиками (для определения движения, остановленного пиком при поиске первых уровней)
   int Concur=1;   // кол-во совпадений пиков
   int Visits=0; // кол-во посещений для наиболее посещаемого уровня
   int FlatBegin=0;// время начала флэта
   double PowerLevel=Pic.New; // средний уровень совпавших пиков
   double lev; // lev=LEV[f][0]*Point
   int PicCnt=1; // счетчик вершин, сформировавших флэт
   Pic.Free=-1; // свободная ячейка
   int OldestCell=0,  OldestTime=int(Time[bar]);  // номер и время самой старой ячейки
   int DeletedCell=-1, DeletedTime=int(Time[bar]); // номер и время самой старой удаленной ячейки
   bool  FirstDnFind=false; // факт обнаружения уровня, чтоб не искать ниже 
   //if (Prn) Print(ttt,"              NEW=",NEW," intH=",intH," intL=",intL);
   for (f=0; f<LevelsAmount; f++){// перебираем весь массив фракталов от большего к меньшему
      if (LEV[f][0]==0) {Pic.Free=f; break;} // добрались до нулевых значений, фракталы в массиве закончились
      if (LEV[f][1]<OldestTime) {OldestTime=LEV[f][1]; OldestCell=f;} // самый старый фрактал из действующих уровней на случай, если не найдется свободных ячеек массива
      if (LEV[f][9]==0 && LEV[f][1]<DeletedTime) {DeletedTime=LEV[f][1]; DeletedCell=f;}// самый старый из псевдоудаленных, в первую очередь писать лучше туда
      Shift=iBarShift(NULL,0,LEV[f][1],false); // сдвиг фрактала из массива относительно текущего (нулевого) бара
      lev=LEV[f][0]*Point;
      // О П Р Е Д Е Л Е Н И Е   Ф Л Э Т А
      if (MathAbs(NEW-LEV[f][0])<LIM){// сравниваемые фракталы в пределах LIM
         LEV[f][2]++; Concur++;// поиск совпадающих уровней, увеличиваем кол-во совпадений
         if (Pic.Dir==LEV[f][5] && //  поиск среди вершин, если впадина - среди впадин
            Time[bar+PicPer]-LEV[f][1]>FlatTime && // сформирован достаточно давно от нового пика
          ((Pic.Dir>0 && int(High[iHighest(NULL,0,MODE_HIGH,Shift-bar+1,bar)]/Point)<NEW+LIM) || // между отобранным и новым пиками ничего не выступает
           (Pic.Dir<0 && int(Low [iLowest (NULL,0,MODE_LOW ,Shift-bar+1,bar)]/Point)>NEW-LIM))){ // между отобранным и новым пиками ничего не выступает  
            PicCnt++; // количество совпавших вершин
            PowerLevel+=lev; // и их сумма для усреднения 
            if (LEV[f][1]>FlatBegin) FlatBegin=LEV[f][1];  // самый свежий пик, совпадающий с новым, чтобы провести между ними противоположную границу флэта    
         }  }//if (PicCnt>2) Print(TimeToString(Time[bar],TIME_DATE | TIME_MINUTES),":  NEW=",NEW,"  PicCnt=",PicCnt," FlatBegin=",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES)," Htop=",High[iHighest(NULL,0,MODE_HIGH,Shift-bar+1,bar)]," Ltop=",Low [iLowest (NULL,0,MODE_LOW ,Shift-bar+1,bar)]);
      pwr=LEV[f][2]+LEV[f][4]; // "Живучесть" уровня = кол-во отскоков + скорость отскока. Определяет, во сколько уменьшается период фрактала при проверке         
      if (LEV[f][2]>PowerCheck && LEV[f][2]>Visits && lev<=FirstUp && lev>=FirstDn) {Visits=LEV[f][2]; MostVisited=lev;}// поиск самого посещаемого уровня
      // И З М Е Р Е Н И Е    Ш И Р И Н Ы    Ф Р А К Т А Л О В
      if (LEV[f][5]>0 && LEV[f][0]+LIM>=int(High[iHighest(NULL,0,MODE_HIGH,(Shift-bar)*2,bar)]/Point)) LEV[f][7]=Shift-bar; // пока фрактал фракталит,
      if (LEV[f][5]<0 && LEV[f][0]-LIM<=int(Low [iLowest (NULL,0,MODE_LOW ,(Shift-bar)*2,bar)]/Point)) LEV[f][7]=Shift-bar; // меряем его ширину
      // У Д А Л Е Н И Е   Н Е Ф Р А К Т А Л Я Щ И Х   У Р О В Н Е Й                  //if (LEV[f][3]==112906) Print(ttt," LEV[",f,"] ",LEV[f][0],"  ",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES)," [2]=",LEV[f][2]," 4=",LEV[f][4]," [3]=",LEV[f][3]);   
      if (PowerPlus<0){// удаление уровня, если после него появились более сильные (развернувшие большее движение)
         for (j=f; j<LevelsAmount; j++){// сравним текущий фрактал с оставшимися ниже по списку, 
            if (LEV[j][0]==0) continue;
            if (LEV[j][5]!=LEV[f][5]) continue; // вершину сравниваем только с вершинами, впадину толко с впадинами
            if (LEV[f][1]<LEV[j][1] && LEV[f][8]<LEV[j][8]){  // текущий фрактал старше и слабее найденного  //if (Prn) Print(ttt,"DEL fLEV[",f,"] ",LEV[f][0],"  ",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES)," [8]=",LEV[f][8]," jLEV[",j,"] ",LEV[j][0],"  ",TimeToString(LEV[j][1],TIME_DATE | TIME_MINUTES)," [8]=",LEV[j][8]);
               LEVEL_DELETE(f,DelSmall); break; // удаляем текущий уровень, сравнивать больше нечего
               }
            if (LEV[f][1]>LEV[j][1] && LEV[f][8]>LEV[j][8]){  // текущий фрактал моложе и сильнее сравниваемого //if (Prn) Print(ttt,"DEL jLEV[",j,"] ",LEV[j][0],"  ",TimeToString(LEV[j][1],TIME_DATE | TIME_MINUTES)," [8]=",LEV[j][8]," fLEV[",f,"] ",LEV[f][0],"  ",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES)," [8]=",LEV[f][8]);
               LEVEL_DELETE(j,DelSmall);  // удаляем сверяемый уровень  
         }  }  }
      else if (LEV[f][7]*pwr<Shift-bar) {LEVEL_DELETE(f,DelSmall); continue;} // фрактал не фракталит с учетом "коэффициента = кол.во совпадений + дальность отскока"
      // П Р О Б И Т И Е   С О Н О П Р А В Л Е Н Н Ы М   Ф Р А К Т А Л О М
      if (LEV[f][6]==0){// еще не пробитый уровень (1-пробит превосходящим пиком, 2-пробит обратным пиком)
         if (LEV[f][5]>0 && Pic.Dir>0 && NEW>LEV[f][0]+LIM) LEV[f][6]=1;// маркировка пробитого уровня если новая вершина сонаправлена с проверяемой и превосходит ее
         if (LEV[f][5]<0 && Pic.Dir<0 && NEW<LEV[f][0]-LIM) LEV[f][6]=1;// маркировка пробитого уровня если новая впадина сонаправлена с проверяемой и ниже ее
         }
      else{// П Р О Б И Т И Е   П Р О Т И В О П О Л О Ж Н Ы М   Ф Р А К Т А Л О М
         if (LEV[f][5]>0 && Pic.Dir<0 && NEW<LEV[f][0]-LIM) {LEV[f][6]=2; LEVEL_DELETE(f,DelBroken); continue;} // пробитая вверх вершина пробивается вниз (и наборот) зеркальной впадиной,
         if (LEV[f][5]<0 && Pic.Dir>0 && NEW>LEV[f][0]+LIM) {LEV[f][6]=2; LEVEL_DELETE(f,DelBroken); continue;} // либо от зеркальной вершины происходит отскок в пределах допуска (т.е. она отработана и не нужна)
         } 
      //  У Д А Л Е Н И Е   П Е Р Е П И Л Е Н Н О Г О   У Р О В Н Я 
      if (LEV[f][9]>0 && LEV[f][6]>0 && LEV[f][5]==Pic.Dir){// пока не псевдоудаленный, пробитый, совпадает с текущим пиком
         BreakBars=0;  for (j=bar; j<Shift; j++) if (High[j]>=lev && Low[j]<=lev) BreakBars++;// от текущего бара до пробитой вершины считаем кол-во бар, перепиливших уровень 
         if (LevBreak>0 && BreakBars>LevBreak) {LEVEL_DELETE(f,0); continue;} // псевдо удаление пробитого уровня   if (Prn) Print(ttt,"LEV[",f,"] ",LEV[f][0],"  ",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES)," BreakBars=",BreakBars);   
         }     
      // ПРОБИТИЕ УРОВНЕЙ ПОКУПКИ/ПРОДАЖИ, смена тренда при пробитии трендовых уровней    //if (Prn && LEV[f][0]==112827) Print(ttt," NEW=",NEW," LIM=",LIM," LEV-LIM=",LEV[f][0]-LIM,"  LEV[",f,"]=",LEV[f][0],"  ",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES), " LEV6=",LEV[f][6]," LEV9=",LEV[f][9]); 
      if (LEV[f][3]>0){// уровень продажи пока не пробит
         center=(LEV[f][0]+LEV[f][3])/2; // основной объем вершины (серединка)
         if (Prn && LEV[f][3]==1277430) Print(ttt,"  LEV[",f,"]=",LEV[f][0]," [3]=",LEV[f][3],"  ",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES)); 
         if (LEV[f][5]>0 && NEW>center && int(High[iLowest (NULL,0,MODE_HIGH,Shift-(bar+PicPer),bar+PicPer)]/Point)<LEV[f][3]) {// уровень продажи пробит и на расстоянии от нового пика до данного уровня продажи хоть один хай опускался ниже него.  
            LEV[f][3]=0; // удаление уровня продажи
            if (LEV[f][7]>=LevPer) {TrendLevBreakUp++; TrendLevBreakDn=0;}} // если это был достаточно широкий уровень, увеличиваем кол-во пробоев вверх, обнуляем пробои вниз  
         if (LEV[f][5]<0 && NEW<center && int(Low [iHighest(NULL,0,MODE_LOW ,Shift-(bar+PicPer),bar+PicPer)]/Point)>LEV[f][3]) {// уровень покупки пробит и на расстоянии от нового пика до данного уровня покупки хоть один лоу поднимался над ним. 
            if (Prn) Print(ttt,"  DEL LEV[",f,"]=",LEV[f][0]," [3]=",LEV[f][3],"  ",TimeToString(LEV[f][1],TIME_DATE | TIME_MINUTES)); 
            LEV[f][3]=0;  // удаление уровня покупки
            if (LEV[f][7]>=LevPer) {TrendLevBreakDn++; TrendLevBreakUp=0;}} // если это был достаточно широкий уровень, увеличиваем кол-во пробоев вниз, обнуляем пробои вверх.       
      }  }
   if (Pic.Free<0){// если пустых ячеек уже нет,  
      if (DeletedCell>-1)  Pic.Free=DeletedCell; // если есть псевдоудаленные, берем самую старую из них (отработанные уровни, оставляемые для сравнения, по которым не строится график)  Print(TimeToString(Time[bar],TIME_DATE | TIME_MINUTES)," DeletedCell[",DeletedCell,"] ",LEV[DeletedCell][0],"  ",TimeToString(LEV[DeletedCell][1],TIME_DATE | TIME_MINUTES));} 
      else                 Pic.Free=OldestCell; // берем просто самую старую
      } 
   if (Impulse<0) Impulse=0; // при PowerPlus<0 Impulse не нужен, т.к. удаление происходит по ширине фрактала
   // БЛИЖАЙШИЙ ПРЕВОСХОДЯЩИЙ ПИК  (для нахождения между ним и Pic.New противолежащего пика. По нему находится движение, которое развернул данный пик и повышающиеся/понижающиеся пики
   if (Pic.Dir>0) {for (f=bar+PicPer+1; f<Bars; f++) {if (High[f]>=High[bar+PicPer]) {ExPicTime=int(Time[f]); break;}}} // совпадающий по направлению, ближайший по времени к новому пику
   else           {for (f=bar+PicPer+1; f<Bars; f++) {if (Low [f]<=Low [bar+PicPer]) {ExPicTime=int(Time[f]); break;}}} // пик должен быть выше (или равен) нового, впадина должна быть ниже (или равна) новой
   Shift=iBarShift(NULL,0,ExPicTime,false);// сдвиг  превосходящего пика
   LEV[Pic.Free][0]=NEW;            // пишем в свободную ячейку значение фрактала
   LEV[Pic.Free][1]=int(Time[bar+PicPer]);    // время фрактала
   LEV[Pic.Free][2]=Concur; // живучесть = кол-во совпадений с предыдущими уровнями 
   if (Pic.Dir>0){// вершина  
      LEV[Pic.Free][3]=int(Low [iHighest(NULL,0,MODE_LOW ,PicPer*2+1,bar)]/Point); // для вершины трендовый уровень не продажу
      OppositeTop=int(Low [iLowest (NULL,0,MODE_LOW ,Shift-(bar+PicPer)+1,bar+PicPer)]/Point); // противоположная впадина, лежащая между новым и превосходящим его пиками (для определения движения, которое развернул данный пик) 
      }
   else{          // впадина      
      LEV[Pic.Free][3]=int(High[iLowest (NULL,0,MODE_HIGH,PicPer*2+1,bar)]/Point); // для впадины трендовый уровень на покупку
      OppositeTop=int(High[iHighest(NULL,0,MODE_HIGH,Shift-(bar+PicPer)+1,bar+PicPer)]/Point);  // противоположная вершина, лежащая между новой и превосходящей его впадинами (для определения движения, которое развернула данная впадина)
      }//if (Prn) Print(ttt," NEW=",NEW," OppositeTop=",OppositeTop," ExPicTime=",TimeToString(ExPicTime,TIME_DATE | TIME_MINUTES));
   LEV[Pic.Free][4]=Impulse;  // доп живучесть - скорость отскока     if (Prn) Print(ttt," Impulse=",Impulse); 
   LEV[Pic.Free][5]=Pic.Dir;  // направление фрактала: 1=ВЕРШИНА, -1=ВПАДИНА
   LEV[Pic.Free][6]=0;        // пробитость уровня: 1-пробит пиком того же направления, 2-пробит пиком противоположного направления
   LEV[Pic.Free][7]=PicPer;   // сила фрактала - период, на котором он фракталит
   LEV[Pic.Free][8]=MathAbs(NEW-OppositeTop); // движение, которое развернул уровень, т.е. его сила. Разность между его пиком и противолежащей вершиной, из которой началось движение.
   LEV[Pic.Free][9]=1;        // 1-активный уровень (отображается на графике), 0-был псевдо удален, т.е. не отображается на графике, а остается в массиве лишь для сравнения с новыми для построения флэтовых уровней.
   AVG_TREND_LEV(NEW,LEV[Pic.Free][3]);// среднеей занчение последних пяти трендовых для стопа
   //FIRST_LEVELS(uf,df);     //if (Prn) Print(ttt," LEV[",d1,"] "," 3=",DN3);
   Shift=iBarShift(NULL,0,LEV[Pic.Free][1],false);// точка отсчета      
   FrPeriod=int(iBarShift(NULL,0,LEV[Pic.Free][8],false) - Shift); // Для Up пика: период от нового пика до предыдущего (выше или равного данному). Т.е. если впоследствии сформируется флэтовый уровень, можно будет проверить наличие повышающихся минимумов для возможности продажи от него
   ArraySort (LEV,WHOLE_ARRAY,0,MODE_DESCEND); // отсортируем массив по убыванию (34, 23, 17, 8, 3, 0, 0, 0) 
   if (PicCnt<2) return; // не набралось совпавших вершин для формирования флэта
   Shift=iBarShift(NULL,0,FlatBegin,false); // сдвиг дальней вершины флэта   
   Trend=0; // Ф Л Э Т
   FlsDel(Pic.Dir);// удаление уровней покупки/продажи от прошлых ложняков
   TrendLevBreakUp=0;   TrendLevBreakDn=0; // сброс кол-ва пробоев трендовых уровней для формирования тренда
   if (Pic.Dir>0){// сформирована вершина
      OppositeTop=iLowest (NULL,0,MODE_LOW ,Shift-(bar+PicPer)+1,bar+PicPer); // номер бара противоположной вершины флэта
      FlatHi=PowerLevel/PicCnt; // верхняя граница флэта
      FlatLo=Low [OppositeTop]; // минимум между крайними вершинами флэта
      FlatHiTime=int(Time[bar+PicPer]);  // время формирования последней вершины флэта для проверки ложняка
      FlatLoTime=int(Time[OppositeTop]); // время формирования противоположной вершины
   }else{ // сформирована впадина
      OppositeTop=iHighest(NULL,0,MODE_HIGH,Shift-(bar+PicPer)+1,bar+PicPer); // номер бара противоположной вершины флэта
      FlatLo=PowerLevel/PicCnt; // нижняя граница флэта - поддержка
      FlatHi=High[iHighest(NULL,0,MODE_HIGH,Shift-(bar+PicPer)+1,bar+PicPer)]; // максимум между двумя впадинами
      FlatHiTime=int(Time[OppositeTop]); // время формирования противоположной вершины
      FlatLoTime=int(Time[bar+PicPer]);  // время формирования последней вершины флэта для проверки ложняка
   }  }
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ   
void LEVEL_DELETE(int LevToDel, int DelFactor){ // параметры: Уровень для удаления, Причина 1-фрактал обмельчал, 2-пробит противоположной вершиной 
   //if (LEV[LevToDel][0]==110574) Print(ttt," LEV[",LevToDel,"][0]=",LEV[LevToDel][0],"  ",TimeToString(Time[bar],TIME_DATE | TIME_MINUTES));
   if (DelFactor==0){ // Задано псевдо удаление "0",  
      LEV[LevToDel][9]=0; // ставим метку, т.е. оставляем уровень в массиве, но не отображаем его на графике 
      LEV[LevToDel][3]=0; // за одно удаляем его трендовый
   }else{// Задано реальное удаление "1" 
      LEV[LevToDel][0]=0; // удаляем само значение цены
      LEV[LevToDel][3]=0; // за одно удаляем его трендовый
      Pic.Free=LevToDel; // номер освободившейся ячейки для новых значений
   }  }
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ   
void AVG_TREND_LEV(int L1, int L2){ // среднее занчение последних пяти трендовых для стопа
   TrendLevels[TrLevCnt]=MathAbs(L1-L2); // разность пика и его трендового уровня (ширина трендового уровня)
   TrLevCnt++; if (TrLevCnt>4) TrLevCnt=0;
   int i,Max=0,Min=TrendLevels[0],Sum=0;
   for (i=0; i<5; i++){
      if (TrendLevels[i]>Max) Max=TrendLevels[i];
      if (TrendLevels[i]<Min) Min=TrendLevels[i];
      Sum+=TrendLevels[i];
      }
   Pic.Avg=(Sum-Max-Min)/3*Point; // Print(" Pic.Avg=",Pic.Avg," Atr=",Pic.Atr);
   }   
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ   
void LIM_DETECT(){   // Допуск совпадений уровней. Расчитывается как меньшее (при LimType<0), среднее (LimType=0) или большее (при LimType>0) из процентов от значений ATR, расстоянием между двумя последними пиками, и целевых движений.
   double LastMovLimit, TargetLimit, FastAtr, SlowAtr;
   int d; // коэффициент проверки: при поиске максимального значения он >1 и наоборот. Т.е. ищется всегда максимальное из двух значений, умноженных на d. Для того, чтобы не писать два разных алгоритма
   int n=0; // кол-во суммируемых значений для нахождения среднего
   if (LimType>=0) {Pic.Lim=0; d=1;} // максимальное из заданных значений
   else {Pic.Lim=-9999999999;d=-1;} // минимальное из заданных значений 
   if (LimATR>0){// %^2 ATR
      FastAtr=iATR(NULL,0,FastAtrPer,bar)*LimATR*LimATR*0.01; 
      SlowAtr=iATR(NULL,0,SlowAtrPer,bar)*LimATR*LimATR*0.01; 
      if (LimType==0) {Pic.Lim+=(FastAtr+SlowAtr)*0.5; n++;} // усредненное значение, либо
      else Pic.Lim=MathMax(FastAtr*d,SlowAtr*d); // большее из двух АТР
      }
   if (LimMov>0){ // %^2 от расстояния между двумя последними пиками
      LastMovLimit=(NewHi-NewLo)*LimMov*LimMov*0.01; // диапазон между последними пиками вверх и вниз 
      if (LimType==0) {Pic.Lim+=LastMovLimit; n++;}      // усредненное значение с предыдущими, либо
      else {if (LastMovLimit*d>Pic.Lim) Pic.Lim=LastMovLimit*d;}// большее из АТРного и флэтного 
      }
   if (LimTarget>0){ // %^2 от целевого движения (вверх+вниз) 
      TargetLimit=(MidMovUp+MidMovDn)*0.5*LimTarget*LimTarget*0.01; // усредненное значение целевых движений
      if (LimType==0) {Pic.Lim+=TargetLimit; n++;} // усредненное значение с предыдущими, либо 
      else {if (TargetLimit*d>Pic.Lim) Pic.Lim=TargetLimit*d;}  // большее из АТРного, флэтного и целевого 
      } 
   if (d<0) Pic.Lim*=d; // сравнивались отрицательные величины, преобразуем в положительное значение 
   if (n>0) Pic.Lim/=n; // при усреднении делим на кол-во слагаемых
   //if (Prn) Print(ttt," Pic.Lim=",NormalizeDouble(Pic.Lim,Digits-1)," FastAtr=",NormalizeDouble(FastAtr,Digits-1)," SlowAtr=",NormalizeDouble(SlowAtr,Digits-1)," LastMovLimit=",NormalizeDouble(LastMovLimit,Digits-1)," TargetLimit=",NormalizeDouble(TargetLimit,Digits-1)," MidMovUp=",NormalizeDouble(MidMovUp,Digits-1)," MidMovDn=",NormalizeDouble(MidMovDn,Digits-1)," n=",n);   
   }
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ   
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ   
void LEVELS_FIND_AROUND(){ // П О И С К   Б Л И З Л Е Ж А Щ И Х   У Р О В Н Е Й 
   u1=-1; u2=-1; u3=-1; d1=-1; d2=-1; d3=-1; um=-1; dm=-1; UP2=0; DN2=0; UP3=0; DN3=0; UpCenter=0; DnCenter=0; 
   int f, uf=-1, df=-1; // номера в массиве крупнейших первых уровней
   int mirUp=Pic.intAtr*5, mirDn=Pic.intAtr*5, FirstLevForce=Pic.intAtr*FirstLev; // первичное расстояние до зеркальных флэтовых
   for (f=0; f<LevelsAmount; f++){// предварительный поиск начала   
      if (LEV[f][0]==0) break; // пошли 00
      if (LEV[f][7]<LevPer || LEV[f][9]==0) continue; // узкие фракталы и псевдо удаленые уровни пропускаем. Они оставлены в массиве для сравнения, но не отображаются на графике
      if (LEV[f][0]>intH && ((LEV[f][5]>0 && LEV[f][6]==0) || LEV[f][5]<0)) u1=f;  //  остановка поиска при первом найденном уровне выше хая. Это должен быть непробитый пик, либо пробитая зеркальная впадина
      if (LEV[f][0]<intL && ((LEV[f][5]<0 && LEV[f][6]==0) || LEV[f][5]>0)) {d1=f; break;}//  остановка поиска при первом найденном уровне ниже лоу. Это должна быть непробитая впадина, либо пробитый зеркальный пик
      } //if (Prn) Print(ttt," LEV[",f,"]=",LEV[f][0]," intH=",intH," u1=",u1);
   if (u1>-1){ // если был найден ближайший фрактал, ищем выше более сильные, трендовые и флэтовые уровни 
      UP1=LEV[u1][0]; // предварительное значение (может быть рядом окажется уровень посильней)
      for (f=u1; f>=0; f--){ // поиск выше найденного UP1
         if (u3>-1 && u2>-1 && uf>-1 && LEV[f][0]-UP1>Pic.intAtr) break; // все уровни найдены
         if (LEV[f][7]<LevPer || LEV[f][9]==0) continue; // узкие фракталы и псевдо удаленые уровни пропускаем. Они оставлены в массиве для сравнения, но не отображаются на графике
         if (LEV[f][0]-UP1<Pic.intAtr && (LEV[f][7]>LEV[u1][7] || LEV[f][2]>LEV[u1][2])) u1=f; // ищем поблизости более широкие[7] фракталы и с большим кол-вом отскоков[2]  && (LEV[f][7]>LEV[u1][7] || LEV[f][2]>LEV[u1][2])
         if (u2<0 && LEV[f][2]>=PowerCheck) u2=f; // поиск сильного уровня с достаточным кол-вом отскоков
         if (LEV[f][5]<0){ // впадина
            if (LEV[f][6]==1 && MathAbs(LEV[f][0]-intH)<mirUp) {um=f; mirUp=MathAbs(LEV[f][0]-intH);} // среди пробитых уровней ищем, от которой может произойти зеркальный отскок
         }else{            // вершина
            if (LEV[f][3]>0 && LEV[f][0]>intH){ // среди вершин, непробитых уровней на продажу   (LEV[f][3]+LEV[f][0])*0.5>intH
               if (u3<0) u3=f; // ближайший уровень на продажу
               if (uf<0 && LEV[f][8]>FirstLevForce) uf=f; // первый уровень на продажу
         }  }  }
      UP1=LEV[u1][0]*Point;   Tup1=LEV[u1][1]; // ближайший уровень над хаем с хотябы одним отскоком  
      TargetUp=LEV[u1][8]*Point;
      if (u3>-1) {UP3=LEV[u3][3]*Point;   UP3Pic=LEV[u3][0]*Point;  UpCenter=(UP3+UP3Pic)*0.5*Point;} // Трендовый уровень на продажу, его пик и его серединка
      if (u2>-1) {UP2=LEV[u2][0]*Point;   Tup2=LEV[u2][1];}// сильный флэтовый уровень с достаточным кол-вом отскоков 
      if (um>-1) {Pic.MirUp=LEV[um][0]*Point; Pic.MirUpTime=LEV[um][1];}  // зеркальный уровень сверху
      //if (MathAbs(High[bar]-Pic.MirUp)>Pic.Atr) Pic.MirUp=0; // пробитие зекрального уровня сверху
      }//if (Prn && uf>=0) Print(ttt," LEV[",uf,"]=",LEV[uf][0],"  ",TimeToString(LEV[uf][1],TIME_DATE | TIME_MINUTES)," 3=",LEV[uf][3]); 
   if (d1>-1){// если был найден ближайший фрактал, ищем ниже более сильные, трендовые и флэтовые уровни 
      DN1=LEV[d1][0]; // предварительное значение (может быть рядом окажется уровень посильней)
      for (f=d1; f<LevelsAmount; f++){ // поиск ниже найденного DN1
         if (LEV[f][0]==0) break; // пошли 000
         if (d3>-1 && d2>-1 && df>-1 && DN1-LEV[f][0]>Pic.intAtr) break; // все уровни найдены
         if (LEV[f][7]<LevPer || LEV[f][9]==0) continue; // узкие фракталы и псевдо удаленые уровни пропускаем. Они оставлены в массиве для сравнения, но не отображаются на графике
         if (LEV[f][6]==1 && LEV[f][5]>0 && MathAbs(LEV[f][0]-intL)<mirDn) {dm=f; mirDn=MathAbs(LEV[f][0]-intL);}// среди пробитых уровней ищем снизу вершинку, от которой может произойти зеркальный отскок
         if (DN1-LEV[f][0]<Pic.intAtr && (LEV[f][7]>LEV[d1][7] || LEV[f][2]>LEV[d1][2])) d1=f; // ищем поблизости более широкие[7] фракталы и с большим кол-вом отскоков[2]   && (LEV[f][7]>LEV[d1][7] || LEV[f][2]>LEV[d1][2])
         if (d2<0 && LEV[f][2]>=PowerCheck) d2=f; // поиск сильного уровня с достаточным кол-вом отскоков 
         if (LEV[f][5]<0 && LEV[f][3]>0 && LEV[f][0]<intL){// среди впадин, непробитых уровней на покупку    (LEV[f][3]+LEV[f][0])*0.5<intL
            if (d3<0)  d3=f; // ближайший уровень на покупку 
            if (df<0 && LEV[f][8]>FirstLevForce) df=f;  // первый уровень на покупку
         }  }
      DN1=LEV[d1][0]*Point;   Tdn1=LEV[d1][1]; // if (Prn) Print(ttt,"  LEV[",d1,"]=",LEV[d1][0],"  ",TimeToString(LEV[d1][1],TIME_DATE | TIME_MINUTES)," L[6]=",LEV[d1][6]," L[5]=",LEV[d1][5]);   
      TargetDn=LEV[d1][8]*Point;
      if (d3>-1) {DN3=LEV[d3][3]*Point;   DN3Pic=LEV[d3][0]*Point;   DnCenter=(DN3+DN3Pic)*0.5;} // Трендовый уровень на покупkу, его пик и его серединка
      if (d2>-1) {DN2=LEV[d2][0]*Point;   Tdn2=LEV[d2][1];}// сильный уровень с достаточным кол-вом отскоков
      if (dm>-1) {Pic.MirDn=LEV[dm][0]*Point;  Pic.MirDnTime=LEV[dm][1];}   // зеркальный   уровень снизу
      //if (MathAbs(Pic.MirDn-Low[bar])>Pic.Atr) {Pic.MirDn=0;}// пробитие зекрального уровня снизу
      //if (Prn) Print(ttt," Pic.MirDn=",Pic.MirDn," fff=",fff,"  ",TimeToString(Pic.MirDnTime,TIME_DATE | TIME_MINUTES), " Pic.Atr=",Pic.Atr);//
      }
   if (Pic.New>0){
      if (Pic.Dir<0 && Pic.New<Pic.MirDn) Pic.MirDn=0; // новая впадина пробила зеркальный уровень снизу, удаляем его
      if (Pic.Dir>0 && Pic.New>Pic.MirUp) Pic.MirUp=0; // новая вершина пробила зеркальный уровень сверху, удаляем его  
      }
   FIRST_LEVELS(uf,df);   //  if (Prn && u2>0) Print(ttt," LEV[",u2,"]=",LEV[u2][0]," Power=",LEV[u2][2]," Pic.Lim=",Pic.Lim);   
   }     //if (Prn) Print(ttt,"d1=",d1," DN1=",DN1," LEV[2]=",LEV[d1][2]," LEV[4]=",LEV[d1][4] );  
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
void FIRST_LEVELS(int FirstUpNum, int FirstDnNum){// построение первых уровней по найденным фракталам   
   // сперва просто берутся найденные значения уровней
   if (FirstUpNum>-1){//if (Prn) Print(ttt," FIRST UP LEVEL[",FirstUpNum,"]=",LEV[FirstUpNum][0]*Point," Pic=",LEV[FirstUpNum][5]);
      FirstUp=LEV[FirstUpNum][3]*Point;     // Первый Трендовый на продажу
      FirstUpPic=LEV[FirstUpNum][0]*Point;  // пиковый первого уровня на продажу
      FirstUpCenter=(FirstUp+FirstUpPic)/2; // Серединка с объемом первого трендового 
      FirstUpTime=LEV[FirstUpNum][1];       // время его формирования
      }
   if (FirstDnNum>-1){// if (Prn) Print(ttt," FIRST DN LEVEL[",FirstDnNum,"]=",LEV[FirstDnNum][0]*Point," Pic=",LEV[FirstDnNum][5]);
      FirstDn=LEV[FirstDnNum][3]*Point;     // Первый Трендовый на продажу
      FirstDnPic=LEV[FirstDnNum][0]*Point;  // пиковый первого уровня на продажу
      FirstDnCenter=(FirstDn+FirstDnPic)/2; // Серединка с объемом первого трендового 
      FirstDnTime=LEV[FirstDnNum][1];       // время его формирования
      }
   // доп. проверка на правильность построения. Например, найденный FirstUp левее FirstDn (тренд вниз), но между ними есть более низкий Low<FirstDn    
   //int OldestPic=MathMin(FirstUpTime,FirstDnTime);    // время самого удаленного от текущего бара пика
   //int Shift=iBarShift(NULL,0,OldestPic,false);       // сдвиг самого удаленного пика от текущего бара
   //int LowestBar=iLowest (NULL,0,MODE_LOW ,Shift-bar,bar); // номер бара минимума на периоде до самого удаленного пика
   //int HighestBar=iHighest(NULL,0,MODE_HIGH,Shift-bar,bar); // номер бара максимума на периоде до самого удаленного пика
   //if (FirstDnPic>Low [LowestBar]+Pic.Lim){// отобранный из массива FirstDn оказался не самым низким на промежутке от FirstUp до текущего бара
   //   FirstDn=High[iLowest (NULL,0,MODE_HIGH,PicPer*2+1,LowestBar-PicPer)]; // для впадины трендовый уровень на покупку
   //   FirstDnPic=Low [LowestBar];
   //   FirstDnTime=OldestPic; // Print(TimeToString(Time[bar],TIME_DATE | TIME_MINUTES),":   FirstDnPic=",FirstDnPic," ",TimeToString(FirstDnTime,TIME_DATE | TIME_MINUTES),"   FirstDnPic=",Low [LowestBar]," OldestPicTime=",TimeToString(OldestPic,TIME_DATE | TIME_MINUTES), " FirstDn=",FirstDn);
   //   FirstDnCenter=(FirstDn+FirstDnPic)/2;
   //   }
   //if (FirstUpPic<High[HighestBar]-Pic.Lim){// отобранный из массива FirstUp оказался не самым высоким на промежутке от FirstDn до текущего бара
   //   FirstUp=Low[iHighest(NULL,0,MODE_LOW,PicPer*2+1,HighestBar-PicPer)]; 
   //   FirstUpPic=High[HighestBar];
   //   FirstUpTime=OldestPic; // if (Prn) Print(ttt," FirstUpPic=",FirstUpPic,"  ",TimeToString(FirstUpTime,TIME_DATE | TIME_MINUTES)," High[HighestBar]",High[HighestBar]);
   //   FirstUpCenter=(FirstUp+FirstUpPic)/2; // Серединка с объемом первого трендового        
   //   }  
   } 
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ   
void TREND_DETECT(){ // О П Р Е Д Е Л Е Н И Е   Т Р Е Н Д А 
   if (GlobalTrend< 1 && High[bar]>FirstUpCenter)  GlobalTrend= 1;  // Print(TimeToString(Time[bar],TIME_DATE | TIME_MINUTES)," GlobalTrend=",GlobalTrend);}  
   if (GlobalTrend>-1 && Low[bar]<FirstDnCenter)   GlobalTrend=-1;  // Print(TimeToString(Time[bar],TIME_DATE | TIME_MINUTES)," GlobalTrend=",GlobalTrend);}   
   if (TrNewPic>0){ // Смена тренда при пробитии экстремума новым экстремумом
      if (Trend==0){
         if (NewHi-FlatHi>Pic.Lim) Trend= 1; // пик над границей флэта
         if (FlatLo-NewLo>Pic.Lim) Trend=-1;} // пик под границей флэта
      else{   
         if (NewHi-LastHi>Pic.Lim && NewLo-LastLo>Pic.Lim) Trend= 1; // пик над прошлым пиком
         if (LastLo-NewLo>Pic.Lim && LastHi-NewHi>Pic.Lim) Trend=-1; // пик под прошлым пиком
      }  }
   if (TrOppPic>0){ // Смена тренда при пробитии экстремума противоположным экстремумoм 
      if (Trend==0){
         if (NewLo>FlatHi) Trend= 1;   // над верхней границей флэта сформировалася впадина 
         if (NewHi<FlatLo) Trend=-1;}  // под нижней границей флэта сформировалась вершина
      else{   
         if (NewLo>LastHi) Trend= 1; // над сопротивлением сформировалася впадина 
         if (NewHi<LastLo) Trend=-1; // под поддержкой сформировалась вершина
      }  }
   if (TrLoOnHi>0){ // Смена тренда при пробитии самого низкого максимума минимумом
      if (UP1<LowestHi) LowestHi=UP1; // ищем самый низкий максимум на пробитие среди сильных уровней сопротивления
      if (NewLo>LowestHi) {// пробой сопротивления с пулбэком (нижним фракталом)
         Trend=1; HighestLo=DN1;} //NewHi=HighestLo; фиксируем новую поддержку
      if (DN1>HighestLo) HighestLo=DN1; // ищем самый высокий минимум для пробития среди сильных уровней поддержки
      if (NewHi<HighestLo) { // пробой поддержки с пулбэком (верхним фракталом)
         Trend=-1; LowestHi=UP1; //NewLo=LowestHi; фиксируем новое сопротивление
      }  }
   if (TrLevBrk>0){ // Смена тренда при пробитии трендовых уровней
      if (TrendLevBreakUp>TrLevBrk) Trend= 1; // пробитие подряд TrLevBrk трендовых уровней на продажу
      if (TrendLevBreakDn>TrLevBrk) Trend=-1; // пробитие подряд TrLevBrk трендовых уровней на покупку
   }  }
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
// ЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖЖ
void TARGET_COUNT(){// расчет целевых уровней окончания движения на основании измерения предыдущих безоткатных движений
   double max=0, min=1000000;
   int i;// if (Pic.Dir==LastPic) Print(TimeToString(Time[bar],TIME_DATE | TIME_MINUTES)+"    Pic.Dir==LastPic=",Pic.Dir);
   if (FrDir>0){// при верхнем пике
      TargetDn=NewHi-MidMovDn;// отмеряем цель движения внизу
      if (NewHi-NewLo<Pic.Atr) return; // неправильные пики пропускаем
      if (LastDir!=FrDir) for (i=Movements-1; i>0; i--) MovUp[i]=MovUp[i-1];//пересортировка массива движений лишь в случае чередования пиков, в противном случае просто обновляем последнее значение движения вверх
      MovUp[0]=NewHi-NewLo; // последнее движение вверх
      MidMovUp=0; // определение среднего значения движения вверх
      for (i=0; i<Movements; i++){// среди всех движений вверх
         MidMovUp+=MovUp[i];// суммируем все
         if (MovUp[i]>max) max=MovUp[i]; // ищем максимальное 
         if (MovUp[i]<min) min=MovUp[i]; // и минимальное движения
         }
      MidMovUp=(MidMovUp-max-min)/(Movements-2); // находим среднее движение без аномальных максимального и минимального
      //if (Prn) Print(ttt," NewHi=",NormalizeDouble(NewHi,Digits-1)," Hi-Lo-",NormalizeDouble(NewHi-NewLo,Digits-1)," TargetDn=",NormalizeDouble(TargetDn,Digits-1),"  max=",NormalizeDouble(max,Digits-1)," min=",NormalizeDouble(min,Digits-1)," MidMovUp=",NormalizeDouble(MidMovUp,Digits-1)," MidMovDn=",NormalizeDouble(MidMovDn,Digits-1));
      }    
   else{ // при нижнем пике
      TargetUp=NewLo+MidMovUp;   // отмеряем цель движения вверху
      if (NewHi-NewLo<Pic.Atr) return; // неправильные пики пропускаем Pic.Atr
      if (LastDir!=FrDir) for (i=Movements-1; i>0; i--) MovDn[i]=MovDn[i-1];//пересортировка массива движений лишь в случае чередования пиков, в противном случае просто обновляем последнее значение движения вниз
      MovDn[0]=NewHi-NewLo; // последнее движение вверх
      MidMovDn=0; // определение среднего значения движения вниз
      for (i=0; i<Movements; i++){// среди всех движений вниз
         MidMovDn+=MovDn[i];// суммируем все
         if (MovDn[i]>max) max=MovDn[i]; // ищем максимальное 
         if (MovDn[i]<min) min=MovDn[i]; // и минимальное движения
         }
      MidMovDn=(MidMovDn-max-min)/(Movements-2); // находим среднее движение без аномальных максимального и минимального     
      //if (Prn) Print(ttt," NewLo=",NormalizeDouble(NewLo,Digits-1)," Hi-Lo-",NormalizeDouble(NewHi-NewLo,Digits-1)," TargetUp=",NormalizeDouble(TargetUp,Digits-1),"  max=",NormalizeDouble(max,Digits-1)," min=",NormalizeDouble(min,Digits-1)," MidMovUp=",NormalizeDouble(MidMovUp,Digits-1)," MidMovDn=",NormalizeDouble(MidMovDn,Digits-1));
   }  }
   
   
     
   
    
   
           