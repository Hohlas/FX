int POC[1][4];       // массив с POC-ми 
int PocsAmount=100;
int StepUp, StepDn; // шаг POC вверх(вниз) - факт возвышени€ нового значени€ над предыдущим
double minHi,maxLo;
struct PocLevels{  //  C “ – ”   “ ” – ј   P O C
   int    Lev2;   // старый POC
   int    Lev1;   // новый POC в историю
   double Lev;    // новый POC на график
   double Up;  // ближайший прошлый уровень POC сверху
   double Dn;  // ближайший прошлый уровень POC снизу
   double UpLev;  // верхн€€ граница консолидации, сформированна€ двум€ совпавшими ха€ми бар
   double DnLev;  // нижн€€ граница консолидации, сформированна€ двум€ совпавшими ло€ми бар
   int    StartTime; // врем€ формировани€ POC
   int    Sum; // кол-во совпавших подр€д бар (без пропусков)
   int    Pwr; // сила уровн€ в кол-ве сформировавших его бар
   int    u;   // индекс прошлого верхнего уровн€
   int    d;   // индекс прошлого нижнего уровн€
   int   ATR;  // 
   }Poc;      // 
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆
int POC_INIT(){
   if (PocPer<1) {Print("POC_INIT(): PocPer=",PocPer,". Must be >0"); return(INIT_FAILED);}
   ArrayResize(POC,PocsAmount); // массив с POC-aми
   return (INIT_SUCCEEDED); // ”спешна€ инициализаци€. –езультат выполнени€ функции OnInit() анализируетс€ терминалом только если программа скомпилирована с использованием #property strict.
   } 
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆
void POC(){
   minHi=MathMin(High[bar],minHi); // — каждым новым баром кра€ диапазона minHi и maxLo
   maxLo=MathMax(Low [bar],maxLo); // обрезаютс€ с учетом новых High и Low
   if (minHi > maxLo) Poc.Sum++;// диапазон пересечени€ последних нескольких бар положителен, т.е. ни один бар не выскочил за него: считаем кол-во идущих подр€д бар с общим ценовым диапазоном 
   else{// схлопнулс€
      if (Poc.Sum>PocPer){// совпало достаточное кол-во бар
         minHi=MathMin(High[bar+1],High[bar+2]);   // заново переберем их, только в обратном направлении,
         maxLo=MathMax(Low [bar+1],Low [bar+2]);   // т.к. в последние совпавшие бары могли не попасть бары этого диапазона, не совпавшие с прошлым диапазоном
         Poc.Sum=2; // берем два: прошлый и позапрошлый
         double   poc=(minHi+maxLo)/2, // первичное значение –ќ—
                  PocHiSum=High[bar+1]+High[bar+2],   // попутно будем искать сумму
                  PocLoSum=Low [bar+1]+Low [bar+2];   // хаев и лоу диапазона дл€ нахождени€ его средних верхней и нижней границ
         int err=0;         
         for (int p=bar+3; p<Bars; p++){// заново поиск назад от третьего бара
            if (High[p]>poc && Low[p]<poc){ // бар пересекает –ќ—
               PocHiSum+=High[p]; PocLoSum+=Low[p]; // сумма границ
               Poc.Sum++; // считаем кол-во идущих подр€д бар с общим ценовым диапазоном 
               Poc.StartTime=int(Time[p]); // врем€ самого раннего бара консолидации дл€ ложн€ка
               }
            else err++; // диапазон прервалс€
            if (err>PocPer) break;
            } 
         
         Poc.ATR=int(SlowAtr/Point);  
         POC_SORT(poc,PocHiSum,PocLoSum);// добавление нового уровн€ в массив с имеющимис€, удаление отработанных
         POC_TREND(); // “–≈Ќƒ по перемещению –ќ— относительно друг друга
         }
      Poc.Sum=2; // кол-во совпавших бар = текущий и предыдущий, т.е.
      minHi=MathMin(High[bar],High[bar+1]);   // дл€ дальнейшего
      maxLo=MathMax(Low [bar],Low [bar+1]);   // отслеживани€           
      }
   // ѕќ»—  ¬ ћј——»¬≈ »—“ќ–»„≈— »’ ”–ќ¬Ќ≈…   
   int u=-1, d=-1, p; // 
   int high=int(High[bar]/Point); // целочисленные значени€
   int low =int(Low [bar]/Point); // текущих цен
   if (POC[Poc.u][0]<high){// начало поиска ниже ха€,
      for (p=Poc.u; p>=0; p--){ // поиск вверх
         if (POC[p][2]==0) continue; // !=0 признак разворотной консолидации
         if (POC[p][0]>high) {u=p; break;} // остановка поиска при первом найденном уровне выше ха€
      }  }
   else{// начало поиска выше ха€, 
      for (p=Poc.u; p<PocsAmount; p++){// поиск вниз 
         if (POC[p][2]==0) continue; // !=0 признак разворотной консолидации
         if (POC[p][0]<high) break; else u=p;
      }  } 
   if (POC[Poc.d][0]>low){ // начало поиска выше лоу, 
      for (p=Poc.d; p<PocsAmount; p++){// ищем вниз
         if (POC[p][2]==0) continue; // !=0 признак разворотной консолидации
         if (POC[p][0]==0)  break;// кончились значени€ в массиве
         if (POC[p][0]<low) {d=p; break;}
      }  }
   else{ // начало поиска ниже лоу, 
      for (p=Poc.d; p>=0; p--){ // ищем вверх
         if (POC[p][2]==0) continue; // !=0 признак разворотной консолидации
         if (POC[p][0]>low) break; else d=p;} 
      }
   if (u>=0)   {Poc.u=u;   Poc.Up=POC[u][0]*Point;}   // «апоминаем текущие номера массива дл€ ускорени€ поиска в следующий раз и
   if (d>=0)   {Poc.d=d;   Poc.Dn=POC[d][0]*Point;}   // обновл€ем значени€ индюка      
   }//  }
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆
void POC_SORT(double poc, double PocHiSum, double PocLoSum){// добавление нового уровн€ в массив с имеющимис€, удаление отработанных 
   int Age, free=-1, p, oldest=0, TopCheck=0;
   int NewPoc=int(poc/Point); 
   bool MustDie=false;
   Age=POC[0][1]; // врем€ возникновени€ уровн€ (берем первое попавшеес€)
   if (Poc.Lev1>Poc.Lev2 && Poc.Lev1>NewPoc) TopCheck= 1; // помечаем консолидации, на которых
   if (Poc.Lev1<Poc.Lev2 && Poc.Lev1<NewPoc) TopCheck=-1; // происход€т развороты
   //if (Prn) Print(ttt,"NewPoc=",NewPoc);
   for (p=0; p<PocsAmount; p++){ // перебираем все уровни массива
      if (POC[p][0]==0) {free=p; break;} // добрались до нулевых значений, уровни в массиве закончились
      if (POC[p][1]<Age) {Age=POC[p][1]; oldest=p;} // ищем самый старый уровень, (врем€ возникновени€ минимальное)  на случай если пустых €чеек не будет
      if (TopCheck!=0 && POC[p][0]==Poc.Lev1)  POC[p][2]=TopCheck; // нашли в массиве разворотную консолидацию, вписали тип разворота (вершина/впадина) 
      if ((NewPoc>POC[p][0] && Poc.Lev1<POC[p][0]) || (NewPoc<POC[p][0] && Poc.Lev1>POC[p][0])){ // сравниваемый уровень пилитс€, т.е. новый и предыдущий уровни располагаютс€ по разные стороны от него. 
         POC[p][0]=0; free=p; // удал€ем старый перепиленный уровень, запоминаем освободившуюс€ €чейку 
         continue; // if (Prn) Print(ttt,"Del Middle POC[",p,"]=",POC[p][0]," ", TimeToString(POC[p][1],TIME_DATE | TIME_MINUTES), " NewPoc=",NewPoc," Poc.Lev1=",Poc.Lev1); 
         }  
      if (MathAbs(POC[p][0]-NewPoc)<Poc.ATR){ // старый уровень близко к новому   
         if ((POC[p][2]==1 || POC[p][2]==-1) && POC[p][0]==Poc.Lev1) MustDie=true; // т.к. сравниваемый €вл€етс€ разворотным, необходимо удалить новый уровень if (Prn) Print(ttt,"MustDie NewPoc",NewPoc);
         else   { POC[p][0]=0; free=p;} // if (Prn) Print(ttt,"Del ",POC[p][0]);  
      }  }  
   if (free<0) free=oldest; // если свободных €чеек не нашлось, берем самую старую    
   if (!MustDie){// новый уровень не подлежит удалению, заносим его в массив   
      POC[free][0]=NewPoc;      // значение уровн€ 
      POC[free][1]=int(Time[bar]);  // врем€ возникновени€ уровн€ 
      if (OnlyTop==1)   POC[free][2]=0; // при OnlyTop=1 учитываютс€ только разворотные консолидации. Ётот признак выставл€етс€ при последующих проверках. 
      else              POC[free][2]=2; // т.к. разворотный признак не оцениваетс€, лепим его всем подр€д
      POC[free][3]=Poc.Sum;   // сила уровн€ = кол-во сформировавших его бар (пока не используетс€)
      Poc.Lev=NewPoc*Point;
      Poc.UpLev=(PocHiSum-High[iHighest(NULL,0,MODE_HIGH,Poc.Sum,bar+1)])/(Poc.Sum-1); // средние значени€ верхней и нижней границ дипазона
      Poc.DnLev=(PocLoSum-Low [iLowest (NULL,0,MODE_LOW ,Poc.Sum,bar+1)])/(Poc.Sum-1); // за вычетом экстремальных вылетов 
      }
   Poc.Lev2=Poc.Lev1;  //      пред последнее
   Poc.Lev1=NewPoc;   
   ArraySort(POC,WHOLE_ARRAY,0,MODE_DESCEND); // отсортируем по уровн€м в пор€дке убывани€, т.е. в начале самые высокие, в конце пустые €чейки      
   }    
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆
// ∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆∆   
void POC_TREND(){ // “–≈Ќƒ по перемещению –ќ— относительно друг друга
   if (TrPoc==0) return;
   if (Poc.Lev1-Poc.Lev2>Poc.ATR){  // шаг вверх
      StepDn=0;   // кол-во шагов вниз
      StepUp++;}  // кол-во шагов вверх
   if (Poc.Lev2-Poc.Lev1>Poc.ATR){  // шаг вниз
      StepUp=0;   // кол-во шагов вверх
      StepDn++;   // кол-во шагов вниз
      }
   if (StepDn>=TrPoc)   Trend=-1; // кол-во шагов вниз превысило порог
   if (StepUp>=TrPoc)   Trend= 1; // кол-во шагов вверх превысило порог    
   }  

